{"version":3,"file":"static/js/225.79d52734.chunk.js","mappings":"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","sources":["utils/csvParser.js"],"sourcesContent":["// src/utils/csvParser.js\n\n/**\n * Utility to parse and normalize Google Sheet CSV data to ensure it matches the expected format\n */\n\nimport Papa from 'papaparse';\n\n/**\n * Parse CSV data and convert to standard format, handling various spreadsheet layouts\n * @param {string} csvData - The raw CSV data from Google Sheets\n * @return {Array} - Normalized rows that can be processed by workouts.js\n */\nexport function parseAndNormalizeCSV(csvData) {\n  // Parse the CSV data\n  const parseResult = Papa.parse(csvData, {\n    header: true,\n    skipEmptyLines: true,\n    error: (error) => {\n      console.error(\"CSV parsing error:\", error);\n    }\n  });\n  \n  if (!parseResult.data || parseResult.data.length === 0) {\n    console.error(\"No data found in CSV\");\n    return [];\n  }\n  \n  // Get column headers from the first row\n  const firstRow = parseResult.data[0];\n  const headers = Object.keys(firstRow);\n  \n  // Detect spreadsheet format and normalize\n  const format = detectSpreadsheetFormat(headers);\n  console.log(\"Detected spreadsheet format:\", format);\n  \n  // Normalize the data based on the detected format\n  const normalizedData = normalizeData(parseResult.data, format);\n  \n  return normalizedData;\n}\n\n/**\n * Detect the format of the spreadsheet based on headers\n * @param {Array} headers - Column headers from the spreadsheet\n * @return {string} - Format identifier ('standard', 'lettered', 'custom', etc.)\n */\nfunction detectSpreadsheetFormat(headers) {\n  // Check for standard format with named columns\n  if (headers.includes('Name') && headers.includes('Sets') && headers.includes('Reps')) {\n    return 'standard';\n  }\n  \n  // Check for lettered columns (A, B, C, etc.)\n  const letteredColumns = headers.filter(h => /^[A-Z]$/.test(h));\n  if (letteredColumns.length >= 5) {\n    return 'lettered';\n  }\n  \n  // Check for numbered columns\n  const numberedColumns = headers.filter(h => /^\\d+$/.test(h));\n  if (numberedColumns.length > 0) {\n    return 'numbered';\n  }\n  \n  // Default format\n  return 'custom';\n}\n\n/**\n * Normalize data based on detected format\n * @param {Array} data - The parsed CSV data\n * @param {string} format - The detected format\n * @return {Array} - Normalized data\n */\nfunction normalizeData(data, format) {\n  // If it's already in our standard format, return as is\n  if (format === 'standard') {\n    return data;\n  }\n  \n  // For lettered columns (A, B, C, etc.)\n  if (format === 'lettered') {\n    return data.map(row => {\n      // Try to extract exercise names and details from lettered columns\n      return {\n        A: row.A || '',          // Usually exercise code (A1, B1, etc.)\n        B: row.B || '',          // Usually exercise name\n        C: row.C || '',          // Usually sets\n        D: row.D || '',          // Usually reps\n        E: row.E || '',          // Usually tempo\n        F: row.F || '',          // Usually load\n        G: row.G || '',          // Usually rest\n        H: row.H || '',          // Usually duration\n        I: row.I || '',          // Usually notes\n        ...row                   // Keep other columns for history data\n      };\n    });\n  }\n  \n  // For custom formats, try to map to our expected format\n  return data.map(row => {\n    const normalizedRow = { ...row };\n    \n    // Try to identify and map key columns\n    const headers = Object.keys(row);\n    \n    // Look for exercise name column\n    const nameColumn = headers.find(h => \n      h.toLowerCase().includes('exercise') || \n      h.toLowerCase().includes('name') ||\n      h.toLowerCase().includes('movement')\n    );\n    \n    if (nameColumn) {\n      normalizedRow.B = row[nameColumn];\n    }\n    \n    // Look for sets column\n    const setsColumn = headers.find(h => h.toLowerCase().includes('set'));\n    if (setsColumn) {\n      normalizedRow.C = row[setsColumn];\n    }\n    \n    // Look for reps column\n    const repsColumn = headers.find(h => \n      h.toLowerCase().includes('rep') || \n      h.toLowerCase().includes('count')\n    );\n    if (repsColumn) {\n      normalizedRow.D = row[repsColumn];\n    }\n    \n    // Look for tempo column\n    const tempoColumn = headers.find(h => h.toLowerCase().includes('tempo'));\n    if (tempoColumn) {\n      normalizedRow.E = row[tempoColumn];\n    }\n    \n    // Look for load column\n    const loadColumn = headers.find(h => \n      h.toLowerCase().includes('load') || \n      h.toLowerCase().includes('weight') ||\n      h.toLowerCase().includes('kg')\n    );\n    if (loadColumn) {\n      normalizedRow.F = row[loadColumn];\n    }\n    \n    // Look for rest column\n    const restColumn = headers.find(h => h.toLowerCase().includes('rest'));\n    if (restColumn) {\n      normalizedRow.G = row[restColumn];\n    }\n    \n    // Look for notes column\n    const notesColumn = headers.find(h => h.toLowerCase().includes('note'));\n    if (notesColumn) {\n      normalizedRow.I = row[notesColumn];\n    }\n    \n    return normalizedRow;\n  });\n}\n\n/**\n * Extract history data from the spreadsheet\n * @param {Array} data - The normalized data\n * @return {Object} - Mapping of exercise IDs to history entries\n */\nexport function extractHistoryData(data) {\n  const history = {};\n  \n  // Find date columns (columns that can be parsed as dates)\n  const dateColumns = [];\n  \n  if (data.length === 0) return history;\n  \n  const firstRow = data[0];\n  const headers = Object.keys(firstRow);\n  \n  headers.forEach(header => {\n    // Skip standard exercise detail columns\n    if (['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'].includes(header)) {\n      return;\n    }\n    \n    // Check if the header is a date\n    const possibleDate = parseDate(header);\n    if (possibleDate) {\n      dateColumns.push({\n        column: header,\n        date: possibleDate\n      });\n    }\n  });\n  \n  // Sort date columns chronologically\n  dateColumns.sort((a, b) => a.date - b.date);\n  \n  // Process each row to extract history data\n  data.forEach((row, rowIndex) => {\n    // Skip rows that don't contain exercise data\n    if (!row.A || !row.B || (!row.A.match(/^[A-Z]\\d+$/) && !row.B.match(/^[A-Z]\\d+$/))) {\n      return;\n    }\n    \n    // Generate a unique ID for this exercise \n    // In a real app, you'd need a more robust ID generation strategy\n    const exerciseId = `exercise-${rowIndex}`;\n    \n    const historyEntries = [];\n    \n    // Extract data from each date column\n    dateColumns.forEach(dateCol => {\n      const value = row[dateCol.column];\n      if (value && value.trim() !== '') {\n        historyEntries.push({\n          date: dateCol.date.toISOString().split('T')[0],\n          value: value\n        });\n      }\n    });\n    \n    if (historyEntries.length > 0) {\n      history[exerciseId] = historyEntries;\n    }\n  });\n  \n  return history;\n}\n\n/**\n * Try to parse a string as a date\n * @param {string} dateStr - String that might be a date\n * @return {Date|null} - Date object or null if parsing failed\n */\nfunction parseDate(dateStr) {\n  // Skip empty strings\n  if (!dateStr || dateStr.trim() === '') return null;\n  \n  // Try various date formats\n  const formats = [\n    // DD/MM/YY\n    {\n      regex: /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{2})$/,\n      parse: (match) => new Date(`20${match[3]}-${match[2].padStart(2, '0')}-${match[1].padStart(2, '0')}`)\n    },\n    // DD/MM/YYYY\n    {\n      regex: /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/,\n      parse: (match) => new Date(`${match[3]}-${match[2].padStart(2, '0')}-${match[1].padStart(2, '0')}`)\n    },\n    // MM/DD/YY\n    {\n      regex: /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{2})$/,\n      parse: (match) => new Date(`20${match[3]}-${match[1].padStart(2, '0')}-${match[2].padStart(2, '0')}`)\n    },\n    // MM/DD/YYYY\n    {\n      regex: /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/,\n      parse: (match) => new Date(`${match[3]}-${match[1].padStart(2, '0')}-${match[2].padStart(2, '0')}`)\n    },\n    // YYYY-MM-DD\n    {\n      regex: /^(\\d{4})-(\\d{1,2})-(\\d{1,2})$/,\n      parse: (match) => new Date(`${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`)\n    }\n  ];\n  \n  for (const format of formats) {\n    const match = dateStr.match(format.regex);\n    if (match) {\n      try {\n        const date = format.parse(match);\n        if (!isNaN(date.getTime())) {\n          return date;\n        }\n      } catch (e) {\n        // Parse error, try next format\n      }\n    }\n  }\n  \n  return null;\n}"],"names":["parseAndNormalizeCSV","csvData","parseResult","Papa","header","skipEmptyLines","error","console","data","length","firstRow","format","headers","includes","letteredColumns","filter","h","test","numberedColumns","detectSpreadsheetFormat","Object","keys","log","normalizedData","map","row","A","B","C","D","E","F","G","H","I","normalizedRow","nameColumn","find","toLowerCase","setsColumn","repsColumn","tempoColumn","loadColumn","restColumn","notesColumn","normalizeData","extractHistoryData","history","dateColumns","forEach","possibleDate","dateStr","trim","formats","regex","parse","match","Date","padStart","date","isNaN","getTime","e","parseDate","push","column","sort","a","b","rowIndex","exerciseId","historyEntries","dateCol","value","toISOString","split"],"sourceRoot":""}